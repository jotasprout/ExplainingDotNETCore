<!DOCTYPE html>
<html><head><title>UBC</title><link href="/css/style.css" rel="stylesheet" type="text/css"></head><div><h1>The <i>SOLID</i> Principles of Software Design</h1><p>A 2-3 day course for programmers of any experience level that describes the <i>SOLID</i> principles of Object-Oriented software design, and the associated principles of <i>component</i> design.</p><p><strong>Audience:</strong> </p><ul><li>Programmers of all levels of experience who desire to improve their software design skills._</li></ul><p><strong>Duration:</strong> </p><ul><li>The two day version is weighted towards lecture and demonstration with a minimum of exercises.</li><li>The three day version shifts the weight towards in-class practice and exercises, withoutdiminishing the lectures and demonstrations.</li></ul><p><strong>Outcomes</strong> <br> After this class students will:</p><ul><li>...understand that modules should have only one reason to change; and be ableto structure systems to minimize the effects of change.</li><li>...understand that a good software design allows new features to be added withoutchanging existing code.</li><li>...be able to construct inheritance and polymorphic hierarchies that adhere to a consistentinterface with their users.</li><li>...understand how to separate interfaces and operations so that low level changes to notpropagate to higher levels.</li><li>...have a firm grasp on how to manage the dependencies between source code modules suchthat high level policy does not depend upon low level detail.</li><li>...be able to allocate modules into reusable components.</li><li>...understand how to separate functionality between components in order to minimize change.</li><li>...be able to manage the dependencies between components to minimize crosstalk and deployment thrashing.</li><li>...be able to organize component structures into developable and releasable structures.</li><li>...understand how to connect components such that changes propagate in the right direction.</li><li>...know how to allocate classes to components such that high level components do notdepend on low level components.</li><li>...be familiar with a set of design quality metrics that can be applied to measure the qualityof module and component structures.</li></ul><h2>Outline</h2><ul><li><strong>What goes wrong with Software?</strong><ul><li>Design Smells<ul><li>Rigidity</li><li>Fragility</li><li>Inseparability</li><li>Viscosity</li></ul></li><li>Code Smells  * <p></p></li></ul></li><li><strong>What is OO?</strong><ul><li>History of OO</li><li>Dependency Management</li><li>Dependency Inversion</li><li>Plug-in Architecture<p></p></li></ul></li><li><strong>Code Rot</strong><ul><li>Example: The Copy Program<p></p></li></ul></li><li><strong>The SOLID Principles</strong><br>An in-depth presentation of the principles of class and module design.<ul><li><strong>(SRP)</strong> The Single Reponsibility Principle</li><li><strong>(OCP)</strong> The Open-Closed Principle</li><li><strong>(LSP)</strong> The Liskov Substitution Principle</li><li><strong>(ISP)</strong> The Interface Segregation Principle</li><li><strong>(DIP)</strong> The Dependency Inversion Principle<p></p></li></ul></li><li><strong>Component Principles</strong>An in-depth presentation of the principles of component cohesion and coupling.<ul><li>What is a component?</li><li>Cohesion Principles<ul><li><strong>(REP)</strong> The Release Reuse Equivalence Principle</li><li><strong>(CCP)</strong> The Common Closure Principle</li><li><strong>(CRP)</strong> The Common Reuse Principle</li></ul></li><li>Coupling Principles<ul><li><strong>(ADP)</strong> The Acyclic Dependencies Principle</li><li><strong>(SDP)</strong> The Stable Dependencies Principle</li><li><strong>(SAP)</strong> The Stable Abstractions Principle</li></ul></li><li>Design Quality Metrics<p></p></li></ul></li><li><strong>Exercises.</strong> <br>Several design exercises and demonstrations using UML as time permits.</li></ul> </div></html>